<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <link rel="stylesheet" href="/assets/css/normalize.css">
  <link rel="stylesheet" href="/assets/css/ockham.css">
  <script async src="/assets/js/ockham.js"></script>
  <script async src="https://use.fontawesome.com/releases/v5.15.4/js/all.js"></script>

  

</head>


  <body>
    <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>This is where I'll post writeups and such</p>
  </div>

  
  <nav class="sidebar-nav">
    <ul class="sidebar-nav-list">
    
      <li">
        <a href="/" class="sidebar-nav-item ">
          Feed
        </a>
      </li>
    
      <li">
        <a href="/about/" class="sidebar-nav-item ">
          About
        </a>
      </li>
    
    </ul>
  </nav>
  

  
  <div class="sidebar-item">
    
      <a class="social-icon" href="https://github.com/Day91" target="_blank">
        <i class="fab fa-github" title="GitHub"></i>
      </a>
    
      <a class="social-icon" href="https://app.hackthebox.com/users/185587" target="_blank">
        <i class="fas fa-cube" title="Hack The Box"></i>
      </a>
    
  </div>
  

  <div class="sidebar-item">
    <small>
      Powered by <a href="https://jekyllrb.com/" target="_blank">Jekyll</a> & <a href="https://github.com/zivong/ockham" target="_blank">Ockham</a>
    </small>
  </div>
</div>


    <div class="wrap">
      <div class="container">

        <header class="masthead">
          <div class="masthead-title">
            <a href="/" title="Home">Day91's Blog</a>
            <small>It's daytime somewhere :)</small>
          </div>
        </header>

        <main>
          <article class="post">
  <h1 class="post-title">MapleCTF 2022: Maplewave Challenges</h1>
  <div class="post-meta">
    <time datetime="2022-09-03T00:00:00+01:00" itemprop="datePublished">
      03 Sep 2022
    </time></div>

  <p>The maplewave challenges featured a custom binary to encode audio data in a custom format, with no available playback function. It involved 3 challenges, each with a different encoding method, in which we needed to extract the raw audio data and find a way to play it. My teammates solved the first challenge while I solved the latter two, and in the process I learned a few things about audio signals and different transforms, very much enjoyed playing the challenges!
<!--end_excerpt--></p>

<p><a href="#decoding-the-challenges">To skip to challenge writeups</a></p>
<h1 id="background">Background</h1>
<h2 id="initialisation">Initialisation</h2>
<p>We get the maplewave recording program and maplewave files for each of the challenges(maplewave-0, 1 and 2). To begin solving any of the challenges, we need to understand the base file format and operation of the recorder.</p>

<p>Running the program, we get the arguments list</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>usage: wave [options] &lt;out.maplewave&gt;
Record audio.

Interrupt with ctrl-c when done.

  -c level  set compression level (0-2, default 0)
</code></pre></div></div>
<p>Seeing it takes a compression level from 0-2, and an out file to write the encoded audio to.</p>

<p>Opening the file in binary ninja, we spot that there’s a function for  setting up the maplewave file to be written to. There is a struct we named <code class="language-plaintext highlighter-rouge">struct Context ctx</code> that a lot of the data for the recording is stored in and that is passed to every function that has to handle the recording state, or “context”. Some of these fields can be deciphered now, others will be looked into later.</p>

<p><img src="https://i.imgur.com/kJgq7fC.png" alt="make_file function" />
The bitbuf, bitnum and prev_chunk fields of <code class="language-plaintext highlighter-rouge">struct Context</code> are to be explained later, but for now understand this function as</p>
<ol>
  <li>Opening the file</li>
  <li>Writing the file header: “MPLEWAVE” + qword(compression)</li>
  <li>Initialising the context struct(setting the file pointer and compression, and also number of written bytes)</li>
</ol>

<p>The offset 0xc and 0x28 business is binary ninja’s inability to understand how it accesses multiple fields at once. It is setting one of the fields which we can understand to be the number of bytes written to 0x10, and another to 0x0.</p>

<h2 id="recording-the-audio">Recording the audio</h2>
<p>Going back into the function that calls the file setup, we can witness exactly how it records the audio.</p>

<p>It first runs pa_simple_new(which we can get the documentation for <a href="https://freedesktop.org/software/pulseaudio/doxygen/simple_8h.html#add9a7dce4e15955d4296726c26206689">here</a>) to make a connection to the pulseaudio server for the machine, setting stream direction to PA_STREAM_RECORD in order to record audio data, and passing these settings in a struct as the argument ss which we can break down in binja:
<img src="https://i.imgur.com/028s1yA.png" alt="struct data" />
Channels we don’t need to worry about, but the important settings are that it’s recording data as unsigned 8-bit(what the 0x0 corresponds to) with a sample rate of 16000. Afterwards, the program uses a signal handler to wait for the user to attempt to quit in order to stop the recording, and processes the audio data in 128 byte chunks using a vtable of codec functions. Each of these functions corresponds to a compression method, with maplewave-0 using compression 0, and so on.</p>

<p><a href="#Decoding-the-challenges">To skip to challenge writeups</a></p>
<h2 id="background-knowledge-how-does-audio-data-work">Background knowledge: how does audio data work?</h2>
<p>This isn’t really that important until part 2, and not even that important then, but the background info is useful to have, so I thought I’d talk about it.</p>

<p>Sound waves themselves are <a href="https://en.wikipedia.org/wiki/Longitudinal_wave#:~:text=Longitudinal%20waves%20are%20waves%20in,direction%20of%20the%20wave%20propagation.">longtitudinal waves</a> usually travelling through the air. A uniform sound wave at a given frequency looks like this <img src="http://4.bp.blogspot.com/-axLItxJkAKk/VGnScM0Z5TI/AAAAAAAAFwM/F06iVclqTQo/s1600/displacement-time-graph-sound-wave-nov2012p11q26.png" alt="sine wave" />
When represented on a displacement time axis, with respect to a single particle. This shows the vibration of a particle that is subject to the sound wave over time, with the amplitude(corresponding to volume) being represented by the maximum displacement(peak/trough to middle) and frequency(corresponding to pitch) being the amount of full waves per second.</p>

<p>To sample audio, which is analogue data, a receiver will record thousands of samples of amplitude/displacement per second, the amount per second being the sample rate. A sample resolution determines to what accuracy the data is stored.</p>

<p>In real life, though, most audio data isn’t a simple wave like above - it’s loads of different waves at different frequencies and amplitudes, all interfering and merging with each other to create something as uneven as this <img src="https://i.stack.imgur.com/fuK6Q.png" alt="audio example" />
Which is what speech commonly looks like. In our case, the sample rate is 16000 Hz(16000 per second) and the samples are stored in unsigned 8-bit PCM. -1 to 1 is mapped to 0 to 256, since unsigned is being used. (Should signed be used, -1 would be mapped to -128 and 1 to 127)</p>

<p>We will audacity to process the raw audio data later.</p>
<h1 id="decoding-the-challenges">Decoding the challenges</h1>
<p><a href="#maplewave-0-raw">Challenge 0</a></p>

<p><a href="#maplewave-1-delta-encoding-followed-by-rle">Challenge 1</a></p>

<p><a href="#maplewave-2-discrete-cosine-transform">Challenge 2</a></p>
<h2 id="maplewave-0-raw">maplewave-0: raw</h2>
<p>To solve the first challenge, we must have a look at the first codec function, which we need to remember takes the context pointer as it’s first argument and a block of 128 bytes as it’s second. The function is relatively simple, looking like this <img src="https://i.imgur.com/1iUOgki.png" alt="codec_1" />
The 6th line is subtracting by -0x80, so adding 0x80. The function appears to just write the raw audio data to the file, and so the maplewave-0 file is just some raw unsigned 8-bit audio data. We can remove the header if we want but it is, in reality, negligible. 16 bytes over a 16000 sample rate gets you to one thousandth of a second of mangled audio that’s caused by the header. We just need a way to play this audio data knowing exactly how it is mapped, and <a href="https://www.audacityteam.org/">Audacity</a>, an audio viewer, editor and recorder can help us with this.</p>

<p>Via audacity, we can import the file raw and input the audio settings we already reversed above.
<img src="https://i.imgur.com/DT469iM.png" alt="audio settings" />
The encoding is unsigned 8-bit PCM, only 1 audio channel, at 16000 Hz sample rate.
We could even use the start offset to skip the header, should we have wanted to. Importing it in audacity gives us the audio graph, and we can play it to hear the flag. <img src="https://i.imgur.com/94R3BTs.png" alt="audio graph" />
Note: we actually imported it as signed at first, which gives a kinda earrapey output that does sound like the same words… ish
<img src="https://i.imgur.com/HkPsmZN.png" alt="messed up graph" /></p>
<h4 id="flag-mapleeasy-pulse-code-modulation-5716">Flag: maple{easy pulse code modulation 5716}</h4>
<h2 id="maplewave-1-delta-encoding-followed-by-rle">maplewave-1: delta encoding followed by RLE</h2>
<p>Warning: maplewave-1 is the longest of the 3 challenge writeups</p>
<h3 id="understanding-the-base-encoding">Understanding the base encoding</h3>
<p>The last challenge was mostly a freebie and an introduction to how the system works in these challenges. Now that we have the understanding of how to play the audio data(once we extract it) down, our focus can purely be on the encoding codecs. Now, to solve maplewave-1, we must take a look at the second function.</p>

<p><img src="https://i.imgur.com/A9Z896Q.png" alt="function" />
This is a decompilation of the function in binary ninja with some basic variables understood - it appears to be on a loop through all of the bytes in the data packet, calculating differences between the current and previous bytes. The previous byte is stored in the context object.</p>

<p>Afterwards, it compares the difference to some field in the context(<code class="language-plaintext highlighter-rouge">field_28</code>) and incrementing rdx and setting another field to it <code class="language-plaintext highlighter-rouge">field_2c</code> should they be the same. Otherwise, some complex(ish) logic is employed, running the subroutines at 1380 and 18f0 with various fields as arguments as well as calculations on the difference. Paying attention to the else block, it sets fields 0x28 and 0x2c to 0(thats what the qword at offset 0x28 is), setting <code class="language-plaintext highlighter-rouge">field_28</code> to the byte difference and keeping <code class="language-plaintext highlighter-rouge">field_2c</code> at 0, but setting rdx to this value. With rdx/<code class="language-plaintext highlighter-rouge">field_2c</code> incrementing every time the differences are the same, and then being zero’d after they aren’t, we can infer this is some sort of <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run length encoding</a> compression method(in which data is communicated in terms of the single data packet and “run length”, that is how many times the data is repeated). As opposed to being basic RLE on the audio data(which is unlikely to be effective except for the parts where no data is being broadcasted), it appears to be wrapped around some sort of delta encoding, based on differences.</p>

<p>At this point, I had reduced the logic to this</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For each byte, A[i], do the following, assuming A[0 - 1] = 0:
diff = A[i] - A[i - 1]
If diff = stored diff, then
	run length += 1
	move on
Else, then
	if run length &gt; 0, then
		sub_1380(ctx, 2, 2)
		sub_13f0(ctx, run length)
	run length = 0
	stored diff = 0
	sub_1380(ctx, diff unsigned &gt;&gt; 0x1f, 1)
	rax = diff signed &gt;&gt; 0x1f
	sub_13f0(ctx, (rax ^ diff) - rax)
	rdx = run length
After the loop,
If rdx &gt; 0, then
	sub_1380(ctx, 2, 2)
	sub_13f0(ctx, run length)
</code></pre></div></div>
<p>0x1f is 31, so shifting by that amount(unsigned) preserves only the MSB, the sign bit. That is what <code class="language-plaintext highlighter-rouge">sub_1380</code> is called on first, then an xor calculation based on a <em>signed</em> shift. I struggled on this a lot, trying all sorts of different things before I realised that a signed shift of a negative number by 31 gives -1, always. This helped me realise that (rax ^ diff) - rax computes to diff if rax = 0, but if rax = -1, it is an inversion of 2’s complement(since -1 is represented as 0xffffffff, and an xor by that is the same as a NOT). In conclusion, <code class="language-plaintext highlighter-rouge">sub_1380</code> is called on the sign bit(with 1 as a third argument), and then <code class="language-plaintext highlighter-rouge">sub_13f0</code> is called on the absolute value of the number.</p>

<h3 id="understanding-the-final-layer-of-encoding-sub_1380">Understanding the final layer of encoding: sub_1380</h3>
<p>The subroutines at <code class="language-plaintext highlighter-rouge">1380</code> and <code class="language-plaintext highlighter-rouge">13f0</code> were crucial to being able to decode the audio. The delta run length encoding was relatively simple to invert, but we needed to know how exactly to process the file data into this run length data. Looking at the routine at <code class="language-plaintext highlighter-rouge">13f0</code>, it calls upon the one at <code class="language-plaintext highlighter-rouge">1380</code>, so i decided to look at the latter first.
<img src="https://i.imgur.com/UpdLmYA.png" alt="sub_1380" />
We see some new fields of the context being referenced. With all of the bits hifting and such it was easy to get lost, but in decomposing the code, I could much more easily understand each piece of logic.
The code <code class="language-plaintext highlighter-rouge">rdi_2 = ((1 &lt;&lt; arg3) - 1) &amp; arg2) | field_18 &lt;&lt; arg3</code> is probably the most essential of this function. Breaking it down,</p>
<ol>
  <li>Create a bitmask with arg3 1’s (this is what (1 « arg3) - 1 computes)</li>
  <li>And this mask with arg2</li>
  <li>Shift field_18 up by arg3 bits(thus making room for exactly arg3 bits)</li>
  <li>And the two resulting numbers</li>
</ol>

<p>Steps 1 and 2 can be easily derived to be taking only the lower arg3 bits of arg2 - we can define arg2 to be <code class="language-plaintext highlighter-rouge">data</code>, and arg3 to be <code class="language-plaintext highlighter-rouge">bitnum</code>.
It then appears that what the function does is shift <code class="language-plaintext highlighter-rouge">field_18</code> by <code class="language-plaintext highlighter-rouge">bitnum</code> bits upwards, and then puts the target bits of <code class="language-plaintext highlighter-rouge">data</code> into the resulting gap. This makes <code class="language-plaintext highlighter-rouge">field_18</code> act as “bit buffer” as sorts, so I renamed it <code class="language-plaintext highlighter-rouge">bitbuf</code>.</p>

<p>It then becomes clear that <code class="language-plaintext highlighter-rouge">field_20</code> acts as a tracker for the amount of bits kept in the buffer at a time - what i named <code class="language-plaintext highlighter-rouge">bitlen</code>.</p>

<p>Next thing to tackle is the loop. (I renamed rcx and rdx to their respective fields in the context)
<img src="https://i.imgur.com/KFPYpbN.png" alt="loop" />
The loop appears to be running as long as there are at least 8 bits in the buffer - if there are, it reduces bitlen by 8, and writes the top 8 bits in bitbuf to the file. It doesn’t clear these bits since it’s needless when, by the code execution, only the bits still in scope will ever be handled.</p>

<p>So, it appears that this subroutine’s purpose is to <strong>write a bit sequence to the file</strong>, and that the whole code of this subroutine is a wrapper for that, to handle the <strong>bits to byte conversion</strong>. It thus appears that the data in the file(after the header) is infact to be interpreted as a bitstream.</p>

<p>I named this subroutine <code class="language-plaintext highlighter-rouge">writebits</code>, but it is only called directly from the codec function at the end of a non-zero run, at which point it sends the bits <code class="language-plaintext highlighter-rouge">10</code>(bottom 2 bits of the decimal number 2), which we can remember as a denoter.</p>

<h3 id="understanding-the-final-layer-of-encoding-sub_13f0">Understanding the final layer of encoding: sub_13f0</h3>
<p><img src="https://i.imgur.com/t1huEL9.png" alt="disassembly" />
Unlike the last function there is only one argument aside from the context - a single number, likely one to be sent.
Right off the bat, if the number is 0, it simply writes a single bit - a 0. Otherwise, some interesting bit arithmetic comes into play.</p>

<p>First of all, that <code class="language-plaintext highlighter-rouge">_bit_scan_reverse</code> is compiled into the <code class="language-plaintext highlighter-rouge">bsr</code> instruction, which, upon research, returns the bit index of the most significant bit in the number. That is, the number <code class="language-plaintext highlighter-rouge">0b1</code> would return <code class="language-plaintext highlighter-rouge">0</code>, the number <code class="language-plaintext highlighter-rouge">0b11</code> would return <code class="language-plaintext highlighter-rouge">1</code>, and so forth. The behaviour for this instruction if the number zero is passed is undefined, which is why it checks for that one quickly.</p>

<p>The compilation and therefore decompilation of this section is very.. <em>interesting</em>, as you could probably tell by the various bit shifts and xors. In total, though, it writes a stream of bit 1s corresponding to the bit length of the number in <code class="language-plaintext highlighter-rouge">arg2</code>, and then a 0, allowing us to know when the stream of 1’s is finished. This is an example of unary code.  Afterwards, the data in <code class="language-plaintext highlighter-rouge">arg2</code> is written to the bit stream, however the first <code class="language-plaintext highlighter-rouge">1</code> is removed as we already know the true bit length and so we can reconstruct the original number, saving bits.</p>

<p>This method is not custom by the way - I only found out after the ctf, but it is an implementation of <a href="https://en.wikipedia.org/wiki/Golomb_coding">golomb coding</a>.</p>

<p>Now we understand the complete compression method that the second coded uses, it’s time to write a decoding script.</p>

<h3 id="getting-the-flagfinally">Getting the flag(finally)</h3>
<p>I wrote the following python script, implementing a <code class="language-plaintext highlighter-rouge">BitBuffer</code> class to turn the bytes into a bitstream, and using the logic of the program to unwrap each 128 byte chunk at a time. The nature of the program’s code allows us to 100% know what a specific bit sequence means all the time, with no ambiguity. I added debug information so I could confirm it was correct. There were a few bumps along the way with forgetting bit indexes started at 1, or misunderstanding signed bit shifts, but this is the finished, working, decompression script.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"flag1.maplewave"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span>
<span class="n">f</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BitBuffer</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">file</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">file</span> <span class="o">=</span> <span class="nb">file</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">bitidx</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">getbit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">bitidx</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="nb">file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#print(bin(self.cur)[2:].rjust(8, '0'))
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">&amp;=</span> <span class="mh">0xff</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">bitidx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="nf">givebit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bit</span><span class="p">):</span>
        <span class="c1"># Sometimes you need to reverse the bit stream
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">bitidx</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">bitidx</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="nb">file</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getnum1s</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bit</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">bit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">bit</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">counter</span>
    
    <span class="k">def</span> <span class="nf">getbits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="n">byte</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">byte</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
            <span class="n">byte</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">byte</span>
    
    <span class="k">def</span> <span class="nf">readf0data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">givebit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">bitlen</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getnum1s</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">getbits</span><span class="p">(</span><span class="n">bitlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bitlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">buf</span> <span class="o">=</span> <span class="n">BitBuffer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">run</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="mh">0x80</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">run</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># New block
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="n">firstbit</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
        <span class="k">except</span> <span class="nb">IndexError</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"DONE!"</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"audio"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span>
            <span class="n">out</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">quit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">firstbit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># This means no run(diff will always be positive here as its diff from 0)
</span>            <span class="n">diff</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Diff to start block"</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">diff</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This means run(you're getting 10, designating you just got a run)
</span>            <span class="k">assert</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">runlength</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Run length to start block"</span><span class="p">,</span><span class="n">runlength</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">runlength</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([(</span><span class="n">prev</span> <span class="o">+</span> <span class="n">diff</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">])</span>
            <span class="n">msb</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">msb</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">diff</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Diff"</span><span class="p">,</span><span class="n">diff</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We either have 10 + run + sign + diff, or sign + diff. sign + diff can be 0 + diff or 1 + diff. If it's 1 + diff, first bit of diff sent CANNOT be 0, so we use this logic to proceed.
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="n">firstbit</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
            <span class="n">bailout</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">firstbit</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">buf</span><span class="p">.</span><span class="n">givebit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">bailout</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># its 10 + run + sign + diff
</span>                    <span class="n">runlength</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"Run length"</span><span class="p">,</span><span class="n">runlength</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">runlength</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">prev</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">data</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([(</span><span class="n">prev</span> <span class="o">+</span> <span class="n">diff</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">])</span>
                    <span class="n">msb</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">msb</span><span class="p">:</span>
                        <span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">diff</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"Diff"</span><span class="p">,</span><span class="n">diff</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">firstbit</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bailout</span><span class="p">:</span>
                <span class="c1"># its sign + diff
</span>                <span class="n">msb</span> <span class="o">=</span> <span class="n">firstbit</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">msb</span><span class="p">:</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">diff</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"Diff"</span><span class="p">,</span><span class="n">diff</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">])</span>
        <span class="k">except</span> <span class="nb">IndexError</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"DONE!"</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"audio"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span>
            <span class="n">out</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">quit</span><span class="p">()</span>
</code></pre></div></div>
<p>It works as planned, dumping the raw audio data to the <code class="language-plaintext highlighter-rouge">audio</code> file, so we can use audacity.</p>

<p>Big disclaimer though… this compression <em>should</em> be lossless and yet the audio is pretty janky(lots of random spikes), way more janky than my audio for the next challenge which is lossy compression… so there’s probably an issue in my script somewhere. It works though, the audio is very audible.</p>

<p><img src="https://i.imgur.com/HUtOSNl.png" alt="graph" />
<a href="https://gofile.io/d/oq61sr">mp3 file</a></p>
<h4 id="flag-maplelossless-difference-encoding-3604">Flag: maple{lossless difference encoding 3604}</h4>

<h2 id="maplewave-2-discrete-cosine-transform">maplewave-2: Discrete Cosine Transform</h2>
<p><img src="https://i.imgur.com/6bXBnlX.png" alt="codec_3" />
<img src="https://i.imgur.com/d91JPeq.png" alt="codec_3_final" /></p>

<p>The functions we just reversed(writebits and writenum) make a reapprance, along with incredibly similar RLE code. Except this time, there’s no delta encoding, it’s just RLE based purely on the <strong>processed</strong> data. The processing is what we need to worry about. Binary ninja doesn’t usually do well with floating point calculations as you can see by that abysmal excuse for code, so I switched between it and ghidra for this challenge. 
So now that top loop looks like this<img src="https://i.imgur.com/DOVdstQ.png" alt="ghidra" />
A lot more readable, right?
So it’s converting each byte to a float, subtracting 128, and multiplying by a constant(which is 1/128, by the way). This maps the bytes 0 to 256 to -1 to 1, as we discussed earlier in terms of how audio data is represented. This implies an actual mathematical audio processing algorithm is to be run.</p>

<p>I rewrote <code class="language-plaintext highlighter-rouge">sub_1d80</code>(which is the processor function) in python to understand it a bit better.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">sub_1d80</span><span class="p">(</span><span class="n">float_arr</span><span class="p">):</span>
    <span class="n">float_arr_1</span> <span class="o">=</span> <span class="n">float_arr</span>
    <span class="n">float_arr_2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span> <span class="mh">0x80</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">float_arr_2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="mh">0x80</span><span class="p">:</span>
        <span class="n">float_arr_2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">float_arr_2</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">float_arr_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">float_arr_2</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">float_arr_2</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">float_arr_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">float_arr_2</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">float_arr_2</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="n">float_arr_2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">float_arr_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">4</span>
        <span class="n">float_arr_1</span> <span class="o">=</span> <span class="n">float_arr_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="mi">4</span>
    <span class="n">sub_1a60</span><span class="p">(</span><span class="n">float_arr_2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">float_arr_2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">float_arr</span><span class="p">)):</span>
        <span class="n">float_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">float_arr_2</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="p">[(</span><span class="n">b</span> <span class="o">-</span> <span class="mi">128</span><span class="p">)</span><span class="o">/</span><span class="mi">128</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">arr</span>

<span class="k">def</span> <span class="nf">init_1</span><span class="p">():</span>
    <span class="n">short_arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mh">0x200</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">!=</span> <span class="mh">0x200</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">9</span><span class="p">:</span>
            <span class="n">bVar1</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">|</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">bVar1</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">bVar1</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span>
        <span class="n">short_arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
    <span class="k">return</span> <span class="n">short_arr</span>

<span class="k">def</span> <span class="nf">sub_1a60</span><span class="p">(</span><span class="n">arr2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x200</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">short_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">short_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">fvar15</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">fvar16</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">fvar14</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">arr2</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">arr2</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvar14</span>
            <span class="n">arr2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvar15</span>
            <span class="n">arr2</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvar16</span>
    <span class="n">ivar6</span> <span class="o">=</span> <span class="mi">9</span>
    <span class="n">fvar16</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="n">fvar15</span> <span class="o">=</span> <span class="mf">0.00000009</span>
    <span class="n">ivar7</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">ivar9</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">uvar3</span> <span class="o">=</span> <span class="p">(</span><span class="n">ivar7</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">pfvar8</span> <span class="o">=</span> <span class="n">uvar3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">ivar9</span> <span class="o">&lt;</span> <span class="mh">0x200</span><span class="p">:</span>
            <span class="n">pfvar5</span> <span class="o">=</span> <span class="n">pfvar8</span> <span class="o">+</span> <span class="p">(</span><span class="n">ivar7</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">uvar3</span> <span class="o">*</span> <span class="o">-</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">pfvar5</span> <span class="o">=</span> <span class="n">pfvar5</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">pfvar4</span> <span class="o">=</span> <span class="n">pfvar8</span> <span class="o">+</span> <span class="n">uvar3</span> <span class="o">*</span> <span class="o">-</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">pfvar4</span> <span class="o">=</span> <span class="n">pfvar4</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">fvar12</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">fvar14</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">while</span> <span class="n">pfvar8</span> <span class="o">!=</span> <span class="n">pfvar4</span><span class="p">:</span>
                <span class="n">fvar13</span> <span class="o">=</span> <span class="n">fvar14</span> <span class="o">*</span> <span class="n">arr2</span><span class="p">[</span><span class="n">pfvar5</span><span class="p">]</span> <span class="o">-</span> <span class="n">arr2</span><span class="p">[</span><span class="n">pfvar5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">fvar12</span>
                <span class="n">fvar10</span> <span class="o">=</span> <span class="n">fvar14</span> <span class="o">*</span> <span class="n">arr2</span><span class="p">[</span><span class="n">pfvar5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr2</span><span class="p">[</span><span class="n">pfvar5</span><span class="p">]</span> <span class="o">*</span> <span class="n">fvar12</span>
                <span class="n">fvar1</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">pfvar4</span><span class="p">]</span>
                <span class="n">fvar11</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">pfvar4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">arr2</span><span class="p">[</span><span class="n">pfvar4</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvar13</span> <span class="o">+</span> <span class="n">fvar1</span>
                <span class="n">arr2</span><span class="p">[</span><span class="n">pfvar4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvar10</span> <span class="o">+</span> <span class="n">fvar11</span>
                <span class="n">arr2</span><span class="p">[</span><span class="n">pfvar5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvar11</span> <span class="o">-</span> <span class="n">fvar10</span>
                <span class="n">fvar11</span> <span class="o">=</span> <span class="n">fvar15</span> <span class="o">*</span> <span class="n">fvar12</span>
                <span class="n">arr2</span><span class="p">[</span><span class="n">pfvar5</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvar1</span> <span class="o">-</span> <span class="n">fvar13</span>
                <span class="n">fvar12</span> <span class="o">=</span> <span class="n">fvar14</span> <span class="o">*</span> <span class="n">fvar15</span> <span class="o">+</span> <span class="n">fvar16</span> <span class="o">*</span> <span class="n">fvar12</span>
                <span class="n">pfvar4</span> <span class="o">+=</span> <span class="mi">2</span>
                <span class="n">pfvar5</span> <span class="o">+=</span> <span class="mi">2</span>
                <span class="n">fvar14</span> <span class="o">=</span> <span class="n">fvar14</span> <span class="o">*</span> <span class="n">fvar16</span> <span class="o">-</span> <span class="n">fvar11</span>
            <span class="n">ivar9</span> <span class="o">=</span> <span class="n">ivar9</span> <span class="o">+</span> <span class="n">ivar7</span>
            <span class="n">pfvar8</span> <span class="o">+=</span> <span class="n">ivar7</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">ivar7</span> <span class="o">=</span> <span class="n">ivar7</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">ivar6</span> <span class="o">=</span> <span class="n">ivar6</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ivar6</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">fvar16</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">e</span><span class="p">,</span> <span class="mi">0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ivar7</span><span class="p">))</span>
        <span class="n">fvar15</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.2831853071795862</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ivar7</span><span class="p">)</span>
<span class="n">short_arr</span> <span class="o">=</span> <span class="n">init_1</span><span class="p">()</span> <span class="c1"># generates a table such that short_arr[i] = reversebits(i), with bit length of 9
</span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span> <span class="c1"># to be substituted by audio data
</span><span class="n">data</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">sub_1d80</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<p>This challenge has the math flag, and we were mostly scratching our heads until someone came with a very niche realisation
<img src="https://cdn.discordapp.com/attachments/1015734486136279081/1015734622904123402/Screenshot_2022-09-03_at_22.26.06.png" alt="OSINT the challenge author" />
This was relatively revolutionary for us, and I began to do some research. We realised with all the odd and even indexing that the functions involved used, it was likely dealing in real and imaginary components. <code class="language-plaintext highlighter-rouge">sub_1d80</code>, therefore, took the mapped signal data and converted each signal <code class="language-plaintext highlighter-rouge">x</code> into <code class="language-plaintext highlighter-rouge">0 + 0i, x + 0i</code> , running this forwards in one half of the array and backwards in the other. The fourier transform function is then called on it, and the real parts of the output are returned and converted to integers before encoded into the file.</p>

<p>At the time, I didn’t know that this method of signal splitting before passing to the fourier transform, whilst also only taking the real components, is part of the <a href="https://en.wikipedia.org/wiki/Discrete_cosine_transform">Discrete Cosine Transform</a>. I solved the challenge not even knowing what this thing was, and only looked at it later.</p>

<p>Anyway, I then researched into the Fourier transform. I wrote a decoder script for the RLE encoding, and then searched for ways to invert the processing. I read <a href="https://towardsdatascience.com/understanding-audio-data-fourier-transform-fft-spectrogram-and-speech-recognition-a4072d228520">this article</a>, which explained it well enough. Earlier, I described how real audio data is the interference of several  waves at different frequencies and different amplitudes, resulting in an amplitude vs time audiograph that we are familiar with. The Fourier transform breaks down this audio data into its component frequencies, returning instead a graph of the amplitude of each frequency. The time element is completely removed, so the Fourier transform is usually applied to small sections of the audio data(like, for example, the 128 samples in the maplewave program), and then inversed when required for the audio to be played, “smoothing” the audio into its constituent frequencies and allowing inaudible/noise frequencies to be removed whilst the audio is decomposed - frequencies humans cannot hear can just be removed to save data. This transform is used in real lossy audio processing.</p>

<p>In terms of inverting, I was mostly lost, until I watched a video on <a href="https://www.youtube.com/watch?v=HFacSL--vps">inverting the Fourier transform</a>. The video basically said to take a sine wave at each constituent frequency and “multiply” it by the amplitude for that frequency, and then add all of the waves together and take an average to reconstruct the original data for that small section. “Multiplying” a wave required some complex calculations if complex numbers were involved, but we were only getting the real parts, so it was simple enough.</p>

<p>I modified my decoding script for part 1 to deal in raw values as opposed to deltas, remembering not to invert the (x - 128) / 128 transform. I then applied this function</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">inversefourier</span><span class="p">(</span><span class="n">fourier</span><span class="p">):</span>
    <span class="c1"># There's no way this works
</span>    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fourier</span><span class="p">)):</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="n">i</span> 
        <span class="n">resolution</span> <span class="o">=</span> <span class="mi">128</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cycles</span>
        <span class="n">my_wave</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">length</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">))</span>
        <span class="n">my_wave</span> <span class="o">*=</span> <span class="n">fourier</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">my_wave</span> <span class="o">*=</span> <span class="mi">128</span>
        <span class="n">signal</span> <span class="o">+=</span> <span class="n">my_wave</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">signal</span> <span class="o">/</span> <span class="mi">128</span><span class="p">)</span>
</code></pre></div></div>
<p>to each chunk of 128 samples. It was a pretty naive, but workable, implementation of inverting the transform. I actually ended up converting the float audio data to 8-bit by simply doing a modulo base 256(after multiplying by 128, which was done implicitly in the way I multiplied each of the segments), which meant I had to import it to audacity as signed 8-bit PCM. If I had converted the float to 8-bit the same way the 8-bit had been converted to float, then I would import as unsigned.
The resulting audio was pretty weird, the words <code class="language-plaintext highlighter-rouge">discrete ??? transform seven three eight five</code> were audible. We tried <code class="language-plaintext highlighter-rouge">maple{discrete fourier transform 7385}</code> which didn’t work, and the audio didn’t really sound like it. One of my teammates researched and found out about discrete cosine transform, which fit the audio very much. It turned out that despite the audio making it sound <em>very</em> much like a five, it was a four.
<img src="https://i.imgur.com/QoMJ80z.png" alt="audio graph" />
<a href="https://gofile.io/d/tLDRAZ">mp3 file</a></p>

<h4 id="flag-maplediscrete-cosine-transform-7384">Flag: maple{discrete cosine transform 7384}</h4>
<p>Later, after talking to the author and learning what discrete cosine transform was, I used scipy’s inverse DCT function to create a MUCH cleaner output(this time mapping to unsigned 8-bit). Full script below, original function with less clean output included.
<a href="https://gofile.io/d/IKa9Ib">clean mp3 file</a>(note that the audio is easily discernible, although the jump that made the cosine difficult to hear in the last audio is still there. The fact that it is a four and not a five is easily heard here)</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"flag2.maplewave"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span>
<span class="n">f</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">scipy.fft</span> <span class="kn">import</span> <span class="n">ifft</span><span class="p">,</span> <span class="n">idct</span>
<span class="k">class</span> <span class="nc">BitBuffer</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">file</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">file</span> <span class="o">=</span> <span class="nb">file</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">bitidx</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">getbit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">bitidx</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="nb">file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#print(bin(self.cur)[2:].rjust(8, '0'))
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">&amp;=</span> <span class="mh">0xff</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">bitidx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="nf">givebit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bit</span><span class="p">):</span>
        <span class="c1"># Sometimes you need to reverse the bit stream
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">bitidx</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cur</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">bitidx</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="nb">file</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getnum1s</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bit</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">bit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">bit</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">counter</span>
    
    <span class="k">def</span> <span class="nf">getbits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="n">byte</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">byte</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
            <span class="n">byte</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">byte</span>
    
    <span class="k">def</span> <span class="nf">readf0data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">givebit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">bitlen</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getnum1s</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">getbits</span><span class="p">(</span><span class="n">bitlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bitlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">inversefourier</span><span class="p">(</span><span class="n">fourier</span><span class="p">):</span>
    <span class="k">return</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">idct</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">fourier</span><span class="p">))</span> <span class="o">*</span> <span class="mi">128</span> <span class="o">+</span> <span class="mi">128</span><span class="p">))</span>
    <span class="s">"""
    # There's no way this works
    signal = np.zeros(128)
    for i in range(1, len(fourier)):
        cycles = i 
        resolution = 128
        length = np.pi * 2 * cycles
        my_wave = np.cos(np.arange(0, length, length / resolution))
        my_wave *= fourier[i]
        my_wave *= 128
        signal += my_wave
    return list(signal / 128)
    """</span>

<span class="n">buf</span> <span class="o">=</span> <span class="n">BitBuffer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">run</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="mh">0x80</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">run</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># New block
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="n">firstbit</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
        <span class="k">except</span> <span class="nb">IndexError</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"DONE!"</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"audio"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span>
            <span class="n">out</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">quit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">firstbit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># This means no run(diff will always be positive here as its diff from 0)
</span>            <span class="n">diff</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Diff to start block"</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">diff</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This means run(you're getting 10, designating you just got a run)
</span>            <span class="k">assert</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">runlength</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Run length to start block"</span><span class="p">,</span><span class="n">runlength</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">runlength</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">diff</span><span class="p">]</span>
            <span class="n">msb</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">msb</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">diff</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Diff"</span><span class="p">,</span><span class="n">diff</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">diff</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We either have 10 + run + sign + diff, or sign + diff. sign + diff can be 0 + diff or 1 + diff. If it's 1 + diff, first bit of diff sent CANNOT be 0, so we use this logic to proceed.
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="n">firstbit</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
            <span class="n">bailout</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">firstbit</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">buf</span><span class="p">.</span><span class="n">givebit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">bailout</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># its 10 + run + sign + diff
</span>                    <span class="n">runlength</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"Run length"</span><span class="p">,</span><span class="n">runlength</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">runlength</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">prev</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">diff</span><span class="p">]</span>
                    <span class="n">msb</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getbit</span><span class="p">()</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">msb</span><span class="p">:</span>
                        <span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">diff</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"Diff"</span><span class="p">,</span><span class="n">diff</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">diff</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">firstbit</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bailout</span><span class="p">:</span>
                <span class="c1"># its sign + diff
</span>                <span class="n">msb</span> <span class="o">=</span> <span class="n">firstbit</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">readf0data</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">msb</span><span class="p">:</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">diff</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"Diff"</span><span class="p">,</span><span class="n">diff</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="n">diff</span><span class="p">]</span>
        <span class="k">except</span> <span class="nb">IndexError</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"DONE!"</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"audio"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mh">0x80</span><span class="p">):</span>
                <span class="n">raw</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">%</span><span class="mi">256</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inversefourier</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mh">0x80</span><span class="p">])])</span>
            <span class="n">out</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
            <span class="n">quit</span><span class="p">()</span>

</code></pre></div></div>
<h1 id="conclusion">Conclusion</h1>
<p>Solving these challenges was definitely an enjoyable use of my weekend and I learned a lot about audio data and how it is processed. I liked the challenges a lot and would like to thank xal for the experience!</p>


</article>



<div class="post-pagination">
  
    <a class="post-pagination-item left" href="/pwn/2021/12/29/UIUCTF-2021-PwnyOS.html">
      <i class="fas fa-chevron-left"></i> <span class="post-pagination-title">UIUCTF 2021 PwnyOS 1.1 Challenges
</span>
    </a>
  
  
  
    <a class="post-pagination-item right" href="/pwn/2022/10/07/SekaiCTF-2022-BFS.html">
      <span class="post-pagination-title">SekaiCTF 2022: BFS
</span> <i class="fas fa-chevron-right"></i> 
    </a>
  
</div>

        </main>

        <footer class="footer">
          <small>
            &copy; <time datetime="2022-10-07T12:00:49+01:00">2022</time>&nbsp;<a href="" target="_blank">Day91</a>. All rights reserved.
          </small>
        </footer>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    

    
  </body>
</html>
